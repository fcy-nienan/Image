package com.fcy.Notes;

public class MESI {
    public static void main(String[] args) {
//        MESI协议
        /*
        * M状态   被修改状态,缓存中的值与主存中的值不一致,该缓存行只被缓存在该CPU中
        *        处于M态需要监听其他CPU对主存中改变量的读取操作并在其他CPU读取之前将改变量写入主存
        *        写入后将变为E态
        * E状态   独占状态,缓存中的值与主存中的值一致,该缓存行只被缓存在该CPU中
        *        处于E态需要监听其他CPU对主存中该变量的读取操作并变为S态
        * S状态   共享状态,缓存中的值与主存中的值一致,该缓存行存在于多个CPU的缓存中
        *         处于S态需要监听其他使该缓存行无效的的命令
        *
        *  i=0,执行i++操作
        *  CPU1从主存中加载i到缓存并置该缓存行为E
        *  CPU1从缓存中取数据到寄存器并执行i=i+1 此时寄存器中的值为1  缓存中的值为0  缓存状态为M
        *  CPU2从主存中加载i到缓存    此时CPU1的缓存状态会变为S  CPU2的缓存状态也为S
        *  CPU2从缓存中取数据到寄存器并执行i=i+1 此时寄存器中的值为1  缓存中的值为0  缓存状态为M
        *  CPU2将数据写入缓存    通知其他缓存无效
        *  CPU1发现缓存无效从主存中 可能会从新从主存加载
        *  CPU2发现有其他CPU要读数据则将缓存中的数据写入主存中
        *  CPU1从主存中加载数据 执行CPU的下一个命令--》将寄存器的值写入缓存中
        *  然后其他CPU要从主存中读取数据的时候提前将缓存中的数据写入主存中
        *  可以发现最后主存中的数据还是1   并不是2
        *
        * 上面的步骤可能有些问题  但影响不大
        *  MESI协议只是规定了缓存的操作
        *  但CPU并不会受影响  CPU不会因为缓存行失效就停止写入缓存
        *
        *
        *
        *
        *
        * */
        /*
        * 内存屏障和MESI
        * 指令的乱序产生
        *   指令存放在流水线中
        *   取指令是串行的
        *   但执行的时候因为多个CPU和每条指令执行的时间是不同的，再加上指令的执行是并行的，
        *   所以就会造成一些指令乱序，即顺序流入，乱序流出
        *
        *   乱序的后果
        *       一些指令之间是有上下文因果关系的
        *           显示因果关系:值的依赖
        *           隐式因果关系:单纯从上下文看不出
        *       乱序一般会遵循显示因果关系，所以如果只有显示因果关系，乱序是能保证最终结果是一致的
        *       但如果含有隐式因果关系则无法保证
        *       此时就需要用内存屏障来抑制乱序，以维持程序所期望的逻辑
        *
        *   MESI保证了缓存一致性
        *
        *   缓存一致性的解决方案
        *       1、在总线加LOCK#锁的方式
        *           LOCK锁在总线期间，此时CPU不能访问内存，造成效率低下
        *       2、通过缓存一致性协议(比如MESI协议)
        *
        *
        *   既然有了缓存一致性协议，为何还要通过volatile关键字来保证可见性?
        *
        *
        *   缓存一致性保证的是缓存中的共享变量的值始终一致
        *   内存屏障保证的是部分指令的顺序执行
        *
        *   几个疑问?
        *   MESI中定义的缓存的之间数据同步的指令是CPU指令还是其他的?
        *   它是被CPU执行的吗?
        *   CPU执行其他指令和执行这些指令有什么不同?
        *   一个缓存行为I状态，此时CPU正好要写，该情况下CPU如何操作，
        *   是无视I状态还是放弃写入，
        *   还是重新读取在写入?
        *   缓存何时将新值同步回内存?
        *
        *
        * */
    }
}
